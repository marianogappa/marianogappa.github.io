<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SMBH4M85HZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-SMBH4M85HZ');
  </script>

  <title>Mariano Gappa&#39;s Blog</title>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/chroma.css">
  <link rel="icon" href="/favicon.ico">
  
</head>

<body>
  <header class="header-flex">
    <div class="site-title"><a href="/">Mariano Gappa&#39;s Blog</a></div>
    <nav>
      <ul>
        <li><a href="/about/">About</a></li>
        <li><a href="/projects/">Projects</a></li>
      </ul>
    </nav>
  </header>
  <main class="container">
    
<article class="post">
  <h1 class="post-title">Diffing streams on the terminal</h1>
  <div class="post-meta">
    
    <span class="post-date">Jul 30, 2016</span>
    
    
  </div>
  
  <div class="post-content">
    <h2 id="tldr">TL;DR</h2>
<p>In this blogpost, I describe the most popular tools currently used to diff streams on the terminal, their differences and limitations. Then I introduce a new tool I&rsquo;ve developed, <a href="https://github.com/MarianoGappa/sd">sd</a>, to address some of these limitations.</p>
<h2 id="introduction">Introduction</h2>
<p>Recently, I had this situation at work where I had to come up with a list of unprocessed transactions, identified by some <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>. I had the transaction queue somewhere, and the transaction results somewhere else. Just a &ldquo;set diff&rdquo;, right? Well, my case was not so straightforward.</p>
<h2 id="basic-stream-diffing">Basic stream diffing</h2>
<p>The most common way to do &ldquo;set diffs&rdquo; on the terminal is using <a href="https://en.wikipedia.org/wiki/Comm">comm</a>; and it&rsquo;s also the fastest tool I&rsquo;ve found. Just remember that the streams need to be sorted.</p>
<p>Diffing with comm</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ comm -23 &lt;<span style="color:#f92672">(</span>seq <span style="color:#ae81ff">100</span> | sort<span style="color:#f92672">)</span> &lt;<span style="color:#f92672">(</span>seq <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">100</span> | sort<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>Another (slower but nevertheless popular) way to accomplish the same task is with <code>grep -Fxvf</code>. Note that in this case you don&rsquo;t need to sort the streams, but you have to invert them as you pass them (it looks weird until you realise that the second argument is kind of on the left, because it&rsquo;s often the piped STDIN).</p>
<p>Diffing with grep</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>~ $ grep -Fxvf &lt;<span style="color:#f92672">(</span>seq <span style="color:#ae81ff">6</span> 100<span style="color:#f92672">)</span> &lt;<span style="color:#f92672">(</span>seq 100<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>I discourage the use of <code>grep -Fxvf</code> for two good reasons:</p>
<ul>
<li>
<p>It&rsquo;s slower; maybe not on these examples but it is on real-life examples.</p>
</li>
<li>
<p>It doesn&rsquo;t seem to work properly on the version of grep that comes with OS X  (BSD) for even diffs in the dozen lines. I&rsquo;ve tried the same example on an Alpine container and it just works.</p>
</li>
</ul>
<p>Alpine (<code>grep 2.25-r0</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>~ $ seq <span style="color:#ae81ff">20</span> &gt; a <span style="color:#f92672">&amp;&amp;</span> seq <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">20</span> &gt; b <span style="color:#f92672">&amp;&amp;</span> grep -Fxvf b a
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>OS X (<code>grep (BSD grep) 2.5.1-FreeBSD</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>~ $ seq <span style="color:#ae81ff">20</span> &gt; a <span style="color:#f92672">&amp;&amp;</span> seq <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">20</span> &gt; b <span style="color:#f92672">&amp;&amp;</span> grep -Fxvf b a
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">17</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>
</span></span></code></pre></div><h2 id="what-about-infinite-streams">What about infinite streams?</h2>
<p>The tools mentioned above work with streams that finish, like:</p>
<ul>
<li>files</li>
<li>commands (provided they finish)</li>
<li>sql queries</li>
<li>curl requests (provided they finish or timeout)</li>
</ul>
<p>Infinite streams are ok on the left side stream of the diff, but you can&rsquo;t start diffing until the right side stream finishes.</p>
<p>Note that you can&rsquo;t <code>| sort</code> an infinite stream, so if you plan to diff an infinite stream on the left side, <code>comm</code> is not an option; you have to use <code>grep -Fxvf</code>.</p>
<p>Moreover, if you diff with an infinite stream on the left side, your diff will work but will still never finish. This is fine, unless you want your diff to be part of a script.</p>
<h2 id="common-strategies-for-diffing-infinite-streams">Common strategies for diffing infinite streams</h2>
<p>The two intuitive approaches are:</p>
<ol>
<li>to take the first <em>n</em> items from the infinite stream</li>
<li>to timeout the stream after some time.</li>
</ol>
<p>Taking the first 10 lines from two &ldquo;infinite&rdquo; seqs</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>~ $ comm -23 &lt;<span style="color:#f92672">(</span>seq <span style="color:#ae81ff">10000000000</span> | head -n 10<span style="color:#f92672">)</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>&gt;            &lt;<span style="color:#f92672">(</span>seq <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">10000000000</span> | head -n 10<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>(for brevity, let&rsquo;s assume that <code>seq 10000000000</code> takes infinite time; to be fair it does take an impractical amount of time)</p>
<p>Then there is <a href="http://man7.org/linux/man-pages/man1/timeout.1.html">timeout</a> in the Linux coreutils package for timing out a command after a specified duration. Note that it doesn&rsquo;t come installed in OS X.</p>
<p>The following example is illustrative, because the command varies between systems</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>~ $ comm -23 &lt;<span style="color:#f92672">(</span>timeout 1s seq 10000000000<span style="color:#f92672">)</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>&gt;            &lt;<span style="color:#f92672">(</span>timeout 1s seq <span style="color:#ae81ff">6</span> 10000000000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>If you want <code>timeout</code> on OS X, your best bet is to install coreutils from Homebrew, with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>brew install coreutils
</span></span></code></pre></div><p>and then all coreutils commands are available, with a <code>g</code> prepended to their names (e.g. <code>gtimeout</code>)</p>
<h2 id="the-problem-with-these-strategies">The problem with these strategies</h2>
<p>Both approaches share a common defect: they don&rsquo;t react to stream output.</p>
<p>There&rsquo;s no way to express the following:</p>
<blockquote>
<p>time out after some time has passed with no received lines</p>
</blockquote>
<p>As it turns out, it&rsquo;s quite common to use tools that poll forever, stuck in some form of receive loop.</p>
<p>Examples:</p>
<ul>
<li>A Kafka console consumer, like <a href="https://github.com/fgeller/kt">kt</a> (my originating use case)</li>
<li><code>tail -f</code></li>
<li>Any poll-forever scheme, e.g.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">[[</span> TRUE <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  curl https://status.github.com/api/status.json
</span></span><span style="display:flex;"><span>  sleep <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><h2 id="my-current-solution-sd-stream-differ">My current solution: <code>sd</code> (stream differ)</h2>
<p>I developed a very simple, well-tested, modern and efficient tool for diffing two newline-separated streams, timing them out if necessary. It&rsquo;s written in <a href="https://golang.org/">Go</a>.</p>
<p><a href="https://github.com/MarianoGappa/sd">sd repo @ Github</a></p>
<p>The initial example, with <code>sd</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ seq <span style="color:#ae81ff">100</span> | sd <span style="color:#e6db74">&#39;seq 6 100&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span></code></pre></div><p>Note that <code>sd</code> does not guarantee output order. This is because it violently parallelises work via goroutines. If input is sporadical, output should not come out out of order. If you need sorted output, just add <code>| sort</code> at the end.</p>
<p>If you do add <code>| sort</code> at the end, even though <code>sd</code> will diff right away, you won&rsquo;t see results until <code>sd</code> has finished; this is just how sorting works. Also, <code>sort</code> will give you a natural sort (alphanumerical or numerical, and optionally reverse), but you would still lose the input order.</p>
<p>Use <code>-h</code> or <code>--hard-timeout</code> to timeout after a number of seconds</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ seq <span style="color:#ae81ff">100</span> | sd -h <span style="color:#ae81ff">1</span> <span style="color:#e6db74">&#39;tail -fn 100 &lt;(seq 6 100)&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>Use <code>-t</code> or <code>--timeout</code> to timeout after a number of seconds of no new lines. Note that the two streams hold independent timeouts.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat uuids.txt | sd -t <span style="color:#ae81ff">10</span> <span style="color:#e6db74">&#39;./kafka-consumer.sh uuids_topic&#39;</span>
</span></span><span style="display:flex;"><span>a5aff766-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>a5affbd0-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>a5afff2c-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>a5b00328-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>Usually, tools like <code>mysql</code> or commit log consumers take some time to startup, or to run the query. It makes sense to have a longer timeout period for the first message. Use <code>-p</code> or <code>--patience</code> for this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat uuids.txt | sd -p <span style="color:#ae81ff">20</span> -t <span style="color:#ae81ff">10</span> <span style="color:#e6db74">&#39;./kafka-consumer.sh uuids_topic&#39;</span>
</span></span><span style="display:flex;"><span>a5aff766-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>a5affbd0-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>a5afff2c-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>a5b00328-564a-11e6-beb8-9e71128cae77
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>Use <code>-p 0</code> for waiting indefinitely for the initial message.</p>
<p>If you&rsquo;re sure the second stream will finish, use <code>-i</code> or <code>--infinite</code>; this way you can be confident that <code>sd</code> will wait until the second stream finishes to start diffing.</p>
<h2 id="conclusion">Conclusion</h2>
<p><code>sd</code> is a nifty tool, and a useful addition for a dev&rsquo;s toolbelt. It allows for automation scripts that involve infinite streams; something not readily available currently using GNU-style CLI tools.</p>
<p>It&rsquo;s not perfect: I wouldn&rsquo;t choose it over <code>comm</code> for streams that finish, because even though <code>sd</code> is fast, it does have to check every line of <code>STDIN</code> against every line of the second stream where <code>comm</code> does not. On very long streams, this can get impractically slow. Also, if output order is critical and it doesn&rsquo;t follow a natural order criterion, <code>sd</code> can&rsquo;t be used.</p>
<p>Please, consider <code>sd</code> for your stream diffing needs. <a href="https://github.com/MarianoGappa/sd/issues">Issues</a> and <a href="https://github.com/MarianoGappa/sd/issues#fork-destination-box">PRs</a> are welcome and encouraged: <code>sd</code> is <a href="https://github.com/MarianoGappa/sd/blob/master/LICENSE">MIT licensed</a>.</p>

  </div>
</article>

  </main>
</body>

</html>
