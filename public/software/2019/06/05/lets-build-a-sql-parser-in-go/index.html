<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SMBH4M85HZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-SMBH4M85HZ');
  </script>

  <title>Mariano Gappa&#39;s Blog</title>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/chroma.css">
  <link rel="icon" href="/favicon.ico">
  
</head>

<body>
  <header class="header-flex">
    <div class="site-title"><a href="/">Mariano Gappa&#39;s Blog</a></div>
    <nav>
      <ul>
        <li><a href="/about/">About</a></li>
        <li><a href="/projects/">Projects</a></li>
      </ul>
    </nav>
  </header>
  <main class="container">
    
<article class="post">
  <h1 class="post-title">Let&#39;s build a SQL parser in Go!</h1>
  <div class="post-meta">
    
    <span class="post-date">Jun 5, 2019</span>
    
    
    
    <a href="http://golangweekly.com/issues/265" target="_blank" class="pill-link">
      <div class="pill">
        <img src="/images/icons/golang_weekly.png" alt="icon" class="pill-icon">Golang Weekly

        
        265
        
      </div>
    </a>
    
    
  </div>
  
  <div class="post-content">
    <h2 id="tldr">TL;DR</h2>
<p>This article aims to be the simplest introduction to constructing an <a href="https://en.wikipedia.org/wiki/LL_parser">LL(1) parser</a> in Go, in this case for parsing SQL queries. It assumes minimal programming competence (functions, structs, ifs and for-loops).</p>
<p>Here&rsquo;s the complete parser repository if you want to skip to results:</p>
<p><a href="https://github.com/marianogappa/sqlparser">github.com/marianogappa/sqlparser</a></p>
<h2 id="simplification-disclaimer">Simplification disclaimer</h2>
<p>To make things simple we&rsquo;re gonna descope sub-selects, functions, complex nested expressions and other features that all SQL flavours support. Those features get really involved quickly with the strategy we&rsquo;re gonna use.</p>
<h2 id="1-minute-theory-lesson">1-minute theory lesson</h2>
<p>A parser has two parts:</p>
<ol>
<li>the Lexical Analysis: a.k.a. the &ldquo;<a href="https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization">Tokeniser</a>&rdquo;</li>
<li>the Syntactic Analysis: the creation of the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a></li>
</ol>
<h3 id="lexical-analysis">Lexical Analysis</h3>
<p>Let&rsquo;s define it by example. &ldquo;Tokenising&rdquo; the following query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> id, name <span style="color:#66d9ef">FROM</span> <span style="color:#e6db74">&#39;users.csv&#39;</span>
</span></span></code></pre></div><p>Means extracting the &ldquo;tokens&rdquo; that form this query. The result of the tokeniser would be something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>[]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;SELECT&#34;</span>, <span style="color:#e6db74">&#34;id&#34;</span>, <span style="color:#e6db74">&#34;,&#34;</span>, <span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;FROM&#34;</span>, <span style="color:#e6db74">&#34;&#39;users.csv&#39;&#34;</span>}
</span></span></code></pre></div><h3 id="syntactic-analysis">Syntactic Analysis</h3>
<p>This part is where we actually look at the tokens, make sure they make sense and interpret them to construct some product <code>struct</code> that represents the query in a way that is convenient for the application that is gonna use it (e.g. for executing the query, colour highlighting it). After this step, we&rsquo;d end up with something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">query</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Type</span>: <span style="color:#e6db74">&#34;Select&#34;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">TableName</span>: <span style="color:#e6db74">&#34;users.csv&#34;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Fields</span>: [<span style="color:#e6db74">&#34;id&#34;</span>, <span style="color:#e6db74">&#34;name&#34;</span>],
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are a lot of ways in that parsing can fail, so it would be convenient to do the two steps at the same time and stop as soon as something goes wrong.</p>
<h2 id="strategy">Strategy</h2>
<p>We&rsquo;ll define a <code>parser</code> that looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parser</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sql</span>             <span style="color:#66d9ef">string</span>        <span style="color:#75715e">// The query to parse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i</span>               <span style="color:#66d9ef">int</span>           <span style="color:#75715e">// Where we are in the query
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">query</span>           <span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Query</span>   <span style="color:#75715e">// The &#34;query struct&#34; we&#39;ll build
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">step</span>            <span style="color:#a6e22e">step</span>          <span style="color:#75715e">// What&#39;s this? Read on...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Main function that returns the &#34;query struct&#34; or an error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">Parse</span>() (<span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Query</span>, <span style="color:#66d9ef">error</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A &#34;look-ahead&#34; function that returns the next token to parse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">peek</span>() (<span style="color:#66d9ef">string</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// same as peek(), but advancing our &#34;i&#34; index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">pop</span>() (<span style="color:#66d9ef">string</span>) {}
</span></span></code></pre></div><p>Intuitively, what we would do first is to &ldquo;peek() the first token&rdquo;. In a basic SQL grammar, there are only a few valid initial tokens: SELECT, UPDATE, DELETE, etc; anything else is an error already. The code would look something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToUpper</span>(<span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">peek</span>()) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;SELECT&#34;</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">query</span>.<span style="color:#66d9ef">type</span> = <span style="color:#e6db74">&#34;SELECT&#34;</span> <span style="color:#75715e">// start building the &#34;query struct&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">pop</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO continue with SELECT query parsing...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;UPDATE&#34;</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO handle UPDATE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// TODO other cases...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;invalid query type&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And we can basically fill in the <code>TODO</code>s and profit! However, the diligent reader will see that the code for parsing the whole <code>SELECT</code> query can get messy really quickly, and we have many types of queries to parse. We&rsquo;re gonna need some structure.</p>
<h2 id="finite-state-machines">Finite-state Machines</h2>
<p><a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSMs</a> are a super interesting topic, but we&rsquo;re not here to get a CS degree. Let&rsquo;s just focus on what we need.</p>
<p>At any given point (instead of &ldquo;point&rdquo; let&rsquo;s call it &ldquo;node&rdquo;) in our parsing journey, only a few tokens are valid, and upon finding these tokens we advance to new nodes where different tokens are valid, and so on until we finish parsing our query. We can visualise these node relationships as a directed graph:</p>
<p><img src="/images/posts/sql_parser_graph.png" alt="SQL Parser Graph"></p>
<p>The node transitions can be defined with a simpler table, though:</p>
<p><img src="/images/posts/sql_parser_table.png" alt="SQL Parser Table"></p>
<p>We can directly translate this table to a really large switch statement. We&rsquo;ll use that sneaky <code>parser.step</code> property we defined before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">Parse</span>() (<span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Query</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">step</span> = <span style="color:#a6e22e">stepType</span> <span style="color:#75715e">// initial step
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">sql</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nextToken</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">peek</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">step</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">stepType</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">nextToken</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">UPDATE</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">query</span>.<span style="color:#66d9ef">type</span> = <span style="color:#e6db74">&#34;UPDATE&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">step</span> = <span style="color:#a6e22e">stepUpdateTable</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// TODO cases of other query types
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">stepUpdateSet</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">stepUpdateField</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">stepUpdateComma</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">pop</span>()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">query</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And there we go! Note that some steps might conditionally cycle back to previous ones, like a comma on the <code>SELECT</code> field definition. This strategy scales well for basic parsers. As the grammar grows complex, though, the number of states will increase dramatically, so it can get tedious to write. I recommend testing as you code; more on that below.</p>
<h2 id="peek-implementation">Peek() implementation</h2>
<p>Remember that we need to implement both <code>peek()</code> and <code>pop()</code>. Since they do almost the same, let&rsquo;s use an auxiliary function to keep things <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>. Also, <code>pop()</code> should further advance the index to avoid peeking whitespace.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">peek</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">peeked</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">peekWithLength</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">peeked</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">pop</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">peeked</span>, <span style="color:#a6e22e">len</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">peekWithLength</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">len</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">popWhitespace</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">peeked</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">popWhitespace</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sql</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sql</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>; <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s a list of tokens that we might want to peek:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">reservedWords</span> = []<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;(&#34;</span>, <span style="color:#e6db74">&#34;)&#34;</span>, <span style="color:#e6db74">&#34;&gt;=&#34;</span>, <span style="color:#e6db74">&#34;&lt;=&#34;</span>, <span style="color:#e6db74">&#34;!=&#34;</span>, <span style="color:#e6db74">&#34;,&#34;</span>, <span style="color:#e6db74">&#34;=&#34;</span>, <span style="color:#e6db74">&#34;&gt;&#34;</span>, <span style="color:#e6db74">&#34;&lt;&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;SELECT&#34;</span>, <span style="color:#e6db74">&#34;INSERT INTO&#34;</span>, <span style="color:#e6db74">&#34;VALUES&#34;</span>, <span style="color:#e6db74">&#34;UPDATE&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;DELETE FROM&#34;</span>, <span style="color:#e6db74">&#34;WHERE&#34;</span>, <span style="color:#e6db74">&#34;FROM&#34;</span>, <span style="color:#e6db74">&#34;SET&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In addition to those, we might come across quoted strings or plain identifiers (e.g. field names). Here&rsquo;s a hopefully complete <code>peekWithLength()</code> implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parser</span>) <span style="color:#a6e22e">peekWithLength</span>() (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sql</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">rWord</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">reservedWords</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">token</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sql</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span>:min(len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sql</span>), <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span>len(<span style="color:#a6e22e">rWord</span>))]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">upToken</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToUpper</span>(<span style="color:#a6e22e">token</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">upToken</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">rWord</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">upToken</span>, len(<span style="color:#a6e22e">upToken</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sql</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\&#39;&#39;</span> { <span style="color:#75715e">// Quoted string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">peekQuotedStringWithLength</span>()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">peekIdentifierWithLength</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The remaining functions are trivial and left as an exercise to the reader. If you&rsquo;re curious, the link at the TL;DR section contains the full source code implementation. I intentionally won&rsquo;t link it again here to add a little indirection.</p>
<h2 id="final-validation">Final validation</h2>
<p>The parser might find the end of the string before arriving at a complete query definition. It&rsquo;s probably a good idea to implement a <code>parser.validate()</code> function that looks at the generated &ldquo;query&rdquo; struct, and returns an error if it&rsquo;s incomplete or otherwise wrong.</p>
<h2 id="testing">Testing</h2>
<p>Go&rsquo;s table-driven testing pattern lends itself beautifully for our case:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">testCase</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Name</span>     <span style="color:#66d9ef">string</span>         <span style="color:#75715e">// description of the test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SQL</span>      <span style="color:#66d9ef">string</span>         <span style="color:#75715e">// input sql e.g. &#34;SELECT a FROM &#39;b&#39;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Expected</span> <span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Query</span>    <span style="color:#75715e">// expected resulting &#34;query&#34; struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Err</span>      <span style="color:#66d9ef">error</span>          <span style="color:#75715e">// expected error result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Example tests:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#a6e22e">ts</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">testCase</span>{
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">Name</span>:     <span style="color:#e6db74">&#34;empty query fails&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">SQL</span>:      <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">Expected</span>: <span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Query</span>{},
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">Err</span>:      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;query type cannot be empty&#34;</span>),
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">Name</span>:     <span style="color:#e6db74">&#34;SELECT without FROM fails&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">SQL</span>:      <span style="color:#e6db74">&#34;SELECT&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">Expected</span>: <span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Query</span>{<span style="color:#a6e22e">Type</span>: <span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Select</span>},
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">Err</span>:      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;table name cannot be empty&#34;</span>),
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>Test the test cases like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">tc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ts</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">actual</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">SQL</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Error should have been %v&#34;</span>, <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Err</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Error should have been nil but was %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">require</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Err</span>, <span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;Unexpected error&#34;</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">actual</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">require</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">Expected</span>, <span style="color:#a6e22e">actual</span>[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;Query didn&#39;t match expectation&#34;</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>I&rsquo;m using <a href="https://github.com/stretchr/testify">testify</a> because it provides a diff output when the query structs don&rsquo;t match.</p>
<h2 id="going-deeper">Going deeper</h2>
<p>This experiment is well-suited for:</p>
<ul>
<li>Learning LL(1) parser algorithms</li>
<li>Custom parsing simple grammars with zero dependencies</li>
</ul>
<p>However, this approach can get tedious and it&rsquo;s somewhat limiting. Think about how to parse arbitrarily complex compound expressions (e.g. <code>sqrt(a) = (1 * (2 + 3))</code>).</p>
<p>For a more powerful parsing model, look into <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a>. <a href="https://godoc.org/golang.org/x/tools/cmd/goyacc">goyacc</a> is a popular Go implementation.</p>
<p>I recommend <a href="https://www.youtube.com/watch?v=HxaD_trXwRE">this very interesting talk</a> by Rob Pike on Lexical Scanning.</p>
<p><a href="http://www.cs.binghamton.edu/~zdu/parsdemo/recintro.html">Recursive descent parsing</a> is another parsing approach.</p>
<h2 id="why-i-wrote-this">Why I wrote this</h2>
<p>Recently, I&rsquo;ve decided to centralise my data into a repository of CSVs. As a bonus, it&rsquo;d give me a chance to learn <a href="https://reactjs.org/">React</a> better by creating a UI for <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>ing the data. When I had to decide on an interface for communicating CRUD operations between frontend and backend, I felt SQL was a natural language for it (and I already know it well).</p>
<p>It seems that, although there are many libraries for reading CSV files with SQL, there aren&rsquo;t many that support write operations (particularly <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDL statements</a>). A colleague recommended me to upload the files into an in-memory <a href="https://www.sqlite.org/index.html">SQLite database</a>, run the SQL and then export to CSV; a fine idea since performance wasn&rsquo;t at all a concern for me. In the end, I thought to myself: didn&rsquo;t you always want to write a SQL parser? How hard can it be?</p>
<p>Turns out writing a (basic) parser is very simple! But I bet it can appear daunting without a good tutorial that is as simple as can be.</p>
<p>I hope this can be that tutorial for you. <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS!</a></p>

  </div>
</article>

  </main>
</body>

</html>
